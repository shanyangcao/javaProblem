## Problem

#### poll和peek，pop区别在哪

| **方法** | **作用**                                                     | **是否删除元素** | **适用容器**                | **特殊说明**                              |
| -------- | ------------------------------------------------------------ | ---------------- | --------------------------- | ----------------------------------------- |
| `poll()` | 从容器**队头 / 栈顶**获取并删除元素；若容器为空，返回 `null` | 是               | 队列（如 `Queue`、`Deque`） | 队列的 “出队” 操作                        |
| `peek()` | 从容器**队头 / 栈顶**获取元素，但**不删除**；若容器为空，返回 `null` | 否               | 队列（如 `Queue`、`Deque`） | 仅 “查看” 队头元素，不改变容器            |
| `pop()`  | 从**栈顶**获取并删除元素；若栈为空，会抛出 `EmptyStackException` 异常 | 是               | 栈（如 `Stack`）            | 栈的 “出栈” 操作，是 `Stack` 类的特有方法 |

#### 学习master公式

![img](https://cdn.nlark.com/yuque/0/2025/png/56763514/1760182446940-f6def493-ccbc-42c7-8065-02209ee01f1b.png)

**例 1：归并排序（Merge Sort）**

归并排序的递归逻辑：

- 将数组分成 2 个等大的子数组（`a=2`，`b=2`）。
- 每个子问题规模为`n/2`。
- 合并两个子数组的额外操作时间为`O(n)`（`f(n) = O(n)`）。

递归关系：`T(n) = 2*T(n/2) + O(n)`

计算：

- `log_b a = log_2 2 = 1` → `n^log_b a = n^1 = n`。
- `f(n) = O(n)` 与 `n^log_b a` 相等，符合情况 2。

结论：时间复杂度 `T(n) = O(n log n)`（正确，归并排序确实是`O(n log n)`）。

**例 2：二分查找（Binary Search）**

二分查找的递归逻辑：

- 每次只处理 1 个子问题（`a=1`）。
- 子问题规模为`n/2`（`b=2`）。
- 额外操作仅判断中间元素，时间`O(1)`（`f(n) = O(1)`）。

递归关系：`T(n) = 1*T(n/2) + O(1)`

#### 子数组是什么

**子数组（Subarray）** 是指从原数组中**连续截取**的一段元素组成的新数组，它的核心特征是 “**连续且保持原顺序**”

“子数组” 和 “子序列”“子集” 搞混，三者的核心区别在于**是否连续**和**是否保持顺序**，用表格对比更清晰：

| **概念**   | **连续性要求** | **顺序要求** | **示例（原数组 [1,2,3]）**      |
| ---------- | -------------- | ------------ | ------------------------------- |
| **子数组** | 必须连续       | 必须保持     | [1]、[2,3]、[1,2,3]（共 6 个）  |
| **子序列** | 无需连续       | 必须保持     | [1,3]、[2]（共 7 个）           |
| **子集**   | 无需连续       | 无需保持     | [3,1]、[2,1]（共 8 个，含空集） |

#### Stream流和for有什么区别?

![img](https://cdn.nlark.com/yuque/0/2025/png/56763514/1760239265426-146280ff-2487-40e3-8373-6c9727681a59.png)

#### 遇到哈希表，什么时候用数组，什么时候用set，什么时候用map

数组：适用场景：

- 元素值是较小的整数，例如判断一个字符串中是否包含小写字母，可以用大小为 26 的数组对应 'a' 到 'z'
- 需要统计元素出现的次数，比如在 “有效的字母异位词” 问题中，用数组记录每个字符的频次

set：适用场景：

- 去重操作，例如找出两个数组的交集
- 检查元素是否出现过，如在 “快乐数” 问题中，判断计算过程中是否出现重复的数字

map：适用场景：

- 存储元素之间的映射关系，例如在 “两数之和” 问题中，用 Map 存储数组元素的值和对应的索引
- 统计元素出现的次数，当元素不是整数或范围较大时，用 Map 的键存元素，值存次数

#### 二分查找等场景中，计算中间位置时用 `mid = left + (right - left) / 2` 而不是直接 `mid = (left + right) / 2`

`left + (right - left)/2` 和 `(left + right)/2` 在数学上是完全等价的，问题出在 `left + right` 这一步，	举个极端例子（以 32 位整数为例，最大值 `Integer.MAX_VALUE = 2147483647`）：假设 `left = 2147483640`，`right = 2147483646`（两个数都没溢出，且 `right` 小于最大值）。

- 计算 `left + right` → `2147483640 + 2147483646 = 4294967286`，这个数已经超过了 `Integer.MAX_VALUE`（2147483647），导致**整数溢出**（在 Java 中会变成负数 `-28`，因为整数溢出后会循环到最小值）。
- 此时 `(left + right)/2` 就会变成 `-28 / 2 = -14`，这显然是错误的（正确的中间值应该是 `(2147483640 + 2147483646)/2 = 2147483643`）

#### 数组真的能删除元素吗

组的长度固定，无法真正 “删除” 元素，数组在创建时就确定了长度（比如 `int[] arr = new int[5]`），内存中会分配一块连续的固定大小空间。所谓的 “删除”，本质上是用其他元素覆盖要删除的元素，或者把后面的元素往前挪，覆盖掉目标位置的值。